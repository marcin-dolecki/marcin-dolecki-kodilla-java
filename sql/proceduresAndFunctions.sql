use kodilla_course;
set global log_bin_trust_function_creators=1;

CREATE TABLE BOOKS (
                       BOOK_ID int(11) NOT NULL AUTO_INCREMENT,
                       TITLE varchar(255) NOT NULL,
                       PUBYEAR int(4) NOT NULL,
                       PRIMARY KEY (BOOK_ID)
);

CREATE TABLE READERS (
                         READER_ID int(11) NOT NULL AUTO_INCREMENT,
                         FIRSTNAME varchar(255) NOT NULL,
                         LASTNAME varchar(255) NOT NULL,
                         PESELID varchar(11) NOT NULL,
                         PRIMARY KEY (READER_ID)
);

CREATE TABLE RENTS (
                       RENT_ID int(11) NOT NULL AUTO_INCREMENT,
                       BOOK_ID int(11) NOT NULL,
                       READER_ID int(11) NOT NULL,
                       RENT_DATE datetime NOT NULL,
                       RETURN_DATE datetime,
                       PRIMARY KEY (RENT_ID),
                       FOREIGN KEY (BOOK_ID) REFERENCES BOOKS(BOOK_ID),
                       FOREIGN KEY (READER_ID) REFERENCES READERS(READER_ID)
);

INSERT INTO READERS(FIRSTNAME, LASTNAME, PESELID)
VALUES ('John', 'Smith', '83012217938');

INSERT INTO READERS(FIRSTNAME, LASTNAME, PESELID)
VALUES ('Curtis', 'Wilson', '75121002790');

INSERT INTO READERS(FIRSTNAME, LASTNAME, PESELID)
VALUES ('Cathy', 'Booker', '90112801727');

INSERT INTO READERS(FIRSTNAME, LASTNAME, PESELID)
VALUES ('Marissa', 'Cain', '84061908044');

INSERT INTO READERS(FIRSTNAME, LASTNAME, PESELID)
VALUES ('Muriel', 'Fulton', '76081409269');

COMMIT;

INSERT INTO BOOKS(TITLE, PUBYEAR)
VALUES('The Stranger', 1942);

INSERT INTO BOOKS(TITLE, PUBYEAR)
VALUES ('In Search of Lost Time', 1927);

INSERT INTO BOOKS(TITLE, PUBYEAR)
VALUES ('The Trial', 1925);

INSERT INTO BOOKS(TITLE, PUBYEAR)
VALUES ('The Little Prince', 1943);

INSERT INTO BOOKS(TITLE, PUBYEAR)
VALUES ('Man''s Fate', 1933);

COMMIT;

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (1, 1,DATE_SUB(CURDATE(), INTERVAL 10 DAY), null);

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (8, 1, DATE_SUB(CURDATE(), INTERVAL 10 DAY), null);

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (4, 2, DATE_SUB(CURDATE(), INTERVAL 10 DAY), DATE_SUB(CURDATE(), INTERVAL 5 DAY));

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (1, 3, DATE_SUB(CURDATE(), INTERVAL 8 DAY), null);

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (10, 3, DATE_SUB(CURDATE(), INTERVAL 4 DAY), DATE_SUB(CURDATE(), INTERVAL 2 DAY));

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (10, 4, DATE_SUB(CURDATE(), INTERVAL 10 DAY), DATE_SUB(CURDATE(), INTERVAL 8 DAY));

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (10, 5, DATE_SUB(CURDATE(), INTERVAL 8 DAY), null);

COMMIT;

select * from BOOKS;
select * from READERS;
select * from RENTS;

# PROCEDURE CREATION
DELIMITER $$

CREATE PROCEDURE ListBooks()
BEGIN
    SELECT * FROM BOOKS;
END $$

DELIMITER ;

# CALL THE PROCEDURE
CALL ListBooks();

# TO MODIFY PROCEDURE WE HAVE TO REMOVE IT FIRST AND CREATE A NEW ONE
DROP PROCEDURE IF EXISTS ListBooks;

DELIMITER $$

CREATE PROCEDURE ListBooks()

BEGIN
    SELECT BOOK_ID, TITLE, PUBYEAR FROM BOOKS;
END $$

DELIMITER ;

CALL ListBooks();

# FUNCTIONS
# DROP FUNCTION IF EXISTS VipLevel;
#
# DELIMITER $$
#
# CREATE FUNCTION VipLevel() RETURNS VARCHAR(20) DETERMINISTIC
# BEGIN
#     RETURN 'Standard customer';
# END $$
#
# DELIMITER ;
#
# SELECT VipLevel() AS LEVEL;

# # VipLevel v2
# DROP FUNCTION IF EXISTS VipLevel;
#
# DELIMITER $$
#
# CREATE FUNCTION VipLevel() RETURNS VARCHAR(20) DETERMINISTIC
# BEGIN
#     DECLARE result VARCHAR(20) DEFAULT 'Standard customer';
#     RETURN result;
# END $$
#
# DELIMITER ;
#
# SELECT VipLevel() AS LEVEL;

# VipLevel v3
DROP FUNCTION IF EXISTS VipLevel;

DELIMITER $$

CREATE FUNCTION VipLevel(booksRented INT) RETURNS VARCHAR(20) DETERMINISTIC
BEGIN
    DECLARE result VARCHAR(20) DEFAULT 'Standard customer';
    IF booksRented >= 10 THEN
        SET result = 'Gold customer';
    ELSEIF booksRented >= 5 AND booksRented < 10 THEN
        SET result = 'Silver customer';
    ELSEIF booksRented >= 2 AND booksRented < 5 THEN
        SET result = 'Bronze customer';
    ELSE
        SET result = 'Standard customer';
    END IF;
    RETURN result;
END $$

DELIMITER ;

SELECT VipLevel(12) AS LEVEL;

# TASK 28.1 - GET CUSTOMER NAME BY ID PROCEDURE
DROP PROCEDURE IF EXISTS GetCustomerNameByID;

DELIMITER $$

CREATE PROCEDURE GetCustomerNameByID(IN customerID INT)

BEGIN
    IF customerID <= 0 THEN
        SELECT 'Incorrect customer ID' AS Message;
    ELSE
        SELECT FIRSTNAME AS UserName
        FROM READERS
        WHERE READER_ID = customerID;
    END IF;
END $$

DELIMITER ;

CALL GetCustomerNameByID(2);

# UPDATE READERS TABLE
ALTER TABLE READERS ADD VIP_LEVEL VARCHAR(20);

# # UpdateVipLevels procedure
# DROP PROCEDURE IF EXISTS UpdateVipLevels;
#
# DELIMITER $$
#
# CREATE PROCEDURE UpdateVipLevels()
# BEGIN
#     DECLARE BOOKSREAD INT;
#
#     SELECT COUNT(*) FROM RENTS
#         WHERE READER_ID = 3
#             INTO BOOKSREAD;
#
#     SELECT BOOKSREAD;
# END $$
#
# DELIMITER ;
#
# CALL UpdateVipLevels();
# select * from READERS;

# # UpdateVipLevels procedure v2
# DROP PROCEDURE IF EXISTS UpdateVipLevels;
#
# DELIMITER $$
#
# CREATE PROCEDURE UpdateVipLevels()
# BEGIN
#     DECLARE BOOKSREAD INT;
#     DECLARE DAYS INT;
#
#     SELECT COUNT(*) FROM RENTS
#     WHERE READER_ID = 3
#     INTO BOOKSREAD;
#
#     SELECT DATEDIFF(MAX(RENT_DATE), MIN(RENT_DATE)) + 1 FROM RENTS
#     WHERE READER_ID = 3
#     INTO DAYS;
#
#     SELECT BOOKSREAD, DAYS;
# END $$
#
# DELIMITER ;
#
# CALL UpdateVipLevels();

# # UpdateVipLevels procedure v3
# DROP PROCEDURE IF EXISTS UpdateVipLevels;
#
# DELIMITER $$
#
# CREATE PROCEDURE UpdateVipLevels()
# BEGIN
#     DECLARE BOOKSREAD INT;
#     DECLARE DAYS INT;
#     DECLARE BOOKSPERMONTH DECIMAL(5,2);
#
#     SELECT COUNT(*) FROM RENTS
#     WHERE READER_ID = 3
#     INTO BOOKSREAD;
#
#     SELECT DATEDIFF(MAX(RENT_DATE), MIN(RENT_DATE)) + 1 FROM RENTS
#     WHERE READER_ID = 3
#     INTO DAYS;
#
#     SET BOOKSPERMONTH = BOOKSREAD / DAYS * 30;
#
#     SELECT BOOKSREAD, DAYS, BOOKSPERMONTH;
# END $$
#
# DELIMITER ;
#
# CALL UpdateVipLevels();

# UpdateVipLevels procedure v4
DROP PROCEDURE IF EXISTS UpdateVipLevels;

DELIMITER $$

CREATE PROCEDURE UpdateVipLevels()
BEGIN
    DECLARE BOOKSREAD, DAYS, RDR_ID INT;
    DECLARE BOOKSPERMONTH DECIMAL(5,2);
    DECLARE FINISHED INT DEFAULT 0;
    DECLARE ALL_READERS CURSOR FOR SELECT READER_ID FROM READERS;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET FINISHED = 1;
    OPEN ALL_READERS;

    WHILE (FINISHED = 0) DO
            FETCH ALL_READERS INTO RDR_ID;
            IF (FINISHED=0) THEN
                SELECT COUNT(*) FROM RENTS
                WHERE READER_ID = RDR_ID
                INTO BOOKSREAD;

                SELECT DATEDIFF(MAX(RENT_DATE), MIN(RENT_DATE)) + 1 FROM RENTS
                WHERE READER_ID = RDR_ID
                INTO DAYS;

                SET BOOKSPERMONTH = BOOKSREAD / DAYS * 30;

                UPDATE READERS SET VIP_LEVEL = VipLevel(BOOKSPERMONTH)
                WHERE READER_ID = RDR_ID;
                COMMIT;
            END IF;
        END WHILE;
    CLOSE ALL_READERS;
END $$

DELIMITER ;

CALL UpdateVipLevels();
SELECT * FROM READERS;
SELECT * FROM RENTS;

# Show books per month per by customer id
DROP PROCEDURE IF EXISTS ShowCustomerBooksPerMonthByID;

DELIMITER $$

CREATE PROCEDURE ShowCustomerBooksPerMonthByID(customerID INT)
BEGIN
    DECLARE BOOKSREAD INT;
    DECLARE DAYS INT;
    DECLARE BOOKSPERMONTH DECIMAL(5,2);

    SELECT COUNT(*) FROM RENTS
    WHERE READER_ID = customerID
    INTO BOOKSREAD;

    SELECT DATEDIFF(MAX(RENT_DATE), MIN(RENT_DATE)) + 1 FROM RENTS
    WHERE READER_ID = customerID
    INTO DAYS;

    SET BOOKSPERMONTH = BOOKSREAD / DAYS * 30;

    SELECT customerID AS CUSTOMERID, BOOKSREAD, DAYS, BOOKSPERMONTH;
END $$

DELIMITER ;

CALL ShowCustomerBooksPerMonthByID(2);

# PROCEDURES AND FUNCTIONS STATUS
SHOW PROCEDURE STATUS;
SHOW FUNCTION STATUS;
SHOW CREATE PROCEDURE UpdateVipLevels;

# TEST UPDATE BESTSELLERS
SELECT * FROM BOOKS;
UPDATE BOOKS SET BESTSELLER = NULL WHERE 1=1;
CALL UpdateBestsellers();

# TRIGGERS - SIMPLE
SET @RENTSQTY = 0;

DELIMITER $$

CREATE TRIGGER RENTSCOUNTER BEFORE INSERT ON RENTS
    FOR EACH ROW
BEGIN
    SET @RENTSQTY = @RENTSQTY + 1;
END $$

DELIMITER ;

SELECT @RENTSQTY;
SELECT * FROM RENTS;

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (4,4,DATE_SUB(CURDATE(), INTERVAL 5 DAY), NULL);

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (5,1,DATE_SUB(CURDATE(), INTERVAL 1 DAY), NULL);

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (1,5,DATE_SUB(CURDATE(), INTERVAL 20 DAY), NULL);

INSERT INTO RENTS(BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (2,4,DATE_SUB(CURDATE(), INTERVAL 7 DAY), NULL);

COMMIT;

DROP TRIGGER RENTSCOUNTER;INSERT INTO RENTS (BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (2, 4, DATE_SUB(CURDATE(), INTERVAL 5 DAY), NULL);

COMMIT ;

# TRIGGERS - ADVANCED
CREATE TABLE RENTS_AUD (
    EVENT_ID INT(11) NOT NULL AUTO_INCREMENT,
    EVENT_DATE DATETIME NOT NULL,
    EVENT_TYPE VARCHAR(10) DEFAULT NULL,
    RENT_ID INT(11) NOT NULL,
    OLD_BOOK_ID INT(11),
    NEW_BOOK_ID INT(11),
    OLD_READER_ID INT(11),
    NEW_READER_ID INT(11),
    OLD_RENT_DATE DATETIME,
    NEW_RENT_DATE DATETIME,
    OLD_RETURN_DATE DATETIME,
    NEW_RETURN_DATE DATETIME,
    PRIMARY KEY (EVENT_ID)
);

DELIMITER $$
CREATE TRIGGER RENTS_INSERT AFTER INSERT ON RENTS
    FOR EACH ROW
BEGIN
   INSERT INTO RENTS_AUD (EVENT_DATE, EVENT_TYPE, RENT_ID, NEW_BOOK_ID, NEW_READER_ID, NEW_RENT_DATE, NEW_RETURN_DATE)
       VALUE (CURTIME(), 'INSERT', NEW.RENT_ID, NEW.BOOK_ID,
              NEW.READER_ID, NEW.RENT_DATE, NEW.RETURN_DATE);
END $$
DELIMITER ;

INSERT INTO RENTS (BOOK_ID, READER_ID, RENT_DATE, RETURN_DATE)
VALUES (2, 4, DATE_SUB(CURDATE(), INTERVAL 5 DAY), NULL);

COMMIT ;

SELECT * FROM RENTS;
SELECT * FROM RENTS_AUD;

DELIMITER $$
CREATE TRIGGER RENTS_DELETE AFTER DELETE ON RENTS
    FOR EACH ROW
BEGIN
   INSERT INTO RENTS_AUD (EVENT_DATE, EVENT_TYPE, RENT_ID)
       VALUE (CURTIME(), 'DELETE', OLD.RENT_ID);
END $$
DELIMITER ;

DELETE FROM RENTS WHERE RENT_ID = 11;

COMMIT;

SELECT * FROM RENTS;
SELECT * FROM RENTS_AUD;

DELIMITER $$
CREATE TRIGGER RENTS_UPDATE AFTER UPDATE ON RENTS
    FOR EACH ROW
BEGIN
    INSERT INTO RENTS_AUD (EVENT_DATE, EVENT_TYPE, RENT_ID, NEW_BOOK_ID, NEW_READER_ID, NEW_RENT_DATE, NEW_RETURN_DATE,
                           OLD_BOOK_ID, OLD_READER_ID, OLD_RENT_DATE, OLD_RETURN_DATE)
        VALUE (CURTIME(), 'UPDATE', OLD.RENT_ID, NEW.BOOK_ID,
               NEW.READER_ID, NEW.RENT_DATE, NEW.RETURN_DATE,
              OLD.BOOK_ID, OLD.READER_ID, OLD.RENT_DATE,
               OLD.RETURN_DATE);
END $$
DELIMITER ;

UPDATE RENTS SET RETURN_DATE = CURDATE()
WHERE RENT_ID = 10;

COMMIT;

SELECT * FROM RENTS;
SELECT * FROM RENTS_AUD;

# VIEWS
CREATE VIEW BOOKS_AND_READERS AS
SELECT RD.READER_ID, RD.FIRSTNAME, RD.LASTNAME, BK.TITLE, RT.RENT_DATE, RT.RETURN_DATE
FROM READERS RD, BOOKS BK, RENTS RT
WHERE RT.BOOK_ID = BK.BOOK_ID
AND RT.READER_ID = RD.READER_ID
ORDER BY RT.RENT_DATE;

SELECT * FROM BOOKS_AND_READERS
WHERE RENT_DATE > DATE_SUB(CURDATE(), INTERVAL 12 DAY)
ORDER BY LASTNAME;

# EVENTS
SHOW PROCESSLIST;

CREATE EVENT UPDATE_VIPS
    ON SCHEDULE EVERY 1 MINUTE
    DO CALL UpdateVipLevels();

SELECT * FROM READERS;

DROP EVENT UPDATE_VIPS;

#
SELECT * FROM BOOKS;

# 28.6 Indexes and queries plans
use kodilla_course;
SELECT USER();

CREATE TABLE PHONES (
    PHONE_ID INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
    PHONENUM INT(9),
    FIRSTNAME VARCHAR(50),
    LASTNAME VARCHAR(50)
);

DELIMITER $$
CREATE PROCEDURE FillTestData()
BEGIN
    DECLARE K INT DEFAULT 0;
    WHILE (K < 100000) DO
        INSERT INTO PHONES (PHONENUM,
                            FIRSTNAME,
                            LASTNAME)
        VALUES (ROUND(RAND()*1000000000),
                CONCAT('Firstname number ', K),
                CONCAT('Lastname number ', K));
        IF (MOD(K, 5000) = 0) THEN
            COMMIT;
        END IF;
        SET K = K + 1;
    END WHILE;
    COMMIT;
END $$
DELIMITER ;

CALL FillTestData();

SELECT * FROM PHONES;

CREATE TABLE PHONESTATS (
    ID INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
    RANGE_FROM INT(11),
    RANGE_TO INT(11),
    QUANTITY INT(11)
);

DELIMITER $$
CREATE PROCEDURE CalcPhoneStats()
BEGIN
    DECLARE K INT(11) DEFAULT 99999;
    DECLARE QTY INT(11);
    DELETE FROM PHONESTATS WHERE 1=1;
    COMMIT;
    WHILE (K < 1000000000) DO
        SELECT COUNT(*) FROM PHONES
            WHERE PHONENUM BETWEEN K-99999 AND K
        INTO QTY;
        INSERT INTO PHONESTATS (RANGE_FROM,
                                RANGE_TO,
                                QUANTITY)
        VALUES (K-99999,
                K,
                QTY);
        COMMIT;
        SET K = K + 100000;
    END WHILE;
END $$
DELIMITER ;

CALL CalcPhoneStats();

SELECT * FROM PHONESTATS;

# EXPLAIN
EXPLAIN SELECT COUNT(*) FROM PHONES
WHERE PHONENUM BETWEEN 0 AND 99999;

# INDEX
CREATE INDEX PHONENO ON PHONES (PHONENUM);